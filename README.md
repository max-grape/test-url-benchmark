# test-url-benchmark

## Задача

```
Реализовать микросервис на Golang, который позволяет понять во сколько потоков можно парсить определенный сайт без ошибок (нагрузочное тестирование).
Сервису на вход приходит поисковая строка, например “playstation купить”.
Из поисковой выдачи Яндекса (готовый парсер тут) получаем список урлов.
Далее для каждого урла нужно провести небольшой бенчмарк -- сколько параллельных запросов с одного IP этот урл выдерживает без ошибок.
Максимальное время ответа - до 3 секунд.
Ответом на исходный GET должна быть мапа “хост” => “рекомендуемое количество одновременных потоков”.

Обязательные моменты, которые должны быть реализованы:
- сервис должен быть обернут в docker
- взаимодействие через один эндпоинт GET /sites?search=foobar
- с непрогретым кэшом сервис должен отвечать не дольше 30 сек.
- настройка параметров через конфиг
```

## Реализация

Яндекс возвращает 50 url (в теории N).
Ограничение на ответ для одного url 3s (настраивается).
Тестирование должно занимать не более 30s.
Если тестировать последовательно, то это может занять 50 * 3s = 150s.
Значит надо тестировать параллельно по несколько url (настраивается).
Нужно понимать, что при высоком уровне параллелизма результаты тестирования будут искажаться.
В итоге производительность в руках того, кто настраивает параметры сервиса.

Хотя, возможно в задаче подразумевается написание какого-то хитрого алгоритма, который будет проводить тестирование для
любого числа url за указанное время. Но как по мне, так пытаться протестировать 100500 url за 100ms не очень здраво.

Есть ещё вариант тестировать последовательно, а в хендлере отвечать по таймауту в 30s теми данными,
что успели посчитаться, а остальные продолжать считать в фоне.

В целом же я бы использовал следующую схему: за балансировщиком (Nginx) стоят N сервисов,
которые возвращают данные из кеша (Redis), а при его отсутствии, через брокер сообщений (RabbitMQ)
по RPC сначала получают от N сервисов урлы для тестирования, а затем от N других сервисов результаты тестирования:
```
+--------------+      +-------+      +--------+      +-------+
| Пользователь | ---> | Nginx | ---> |        | ---> | Redis |
+--------------+      +-------+      |        |      +-------+
                                     | Сервис |
                                     |        |      +----------+      +-------------------------------+
                                     |        | ---> |          | ---> | Сервис для обращений к Yandex |
                                     +--------+      |          |      +-------------------------------+
                                                     | RabbitMQ |
                                                     |          |      +-----------------------------+
                                                     |          | ---> | Сервис для тестирования url |
                                                     +----------+      +-----------------------------+
```

### Кеширование

Можно было бы использовать, например, github.com/patrickmn/go-cache, но так как сервис должен иметь возможность
горизонтального масштабирования, то для организации общего адресного пространства используется Redis.

В случае, когда кеш ещё не прогрет, одинаковые запросы к сервису не должны приводить
к параллельным обращениям к Яндексу или излишним тестам.

Данная проблема называется cache stampede (https://habr.com/ru/company/badoo/blog/352186/).

Варианты решения:
  - не обрабатывать запросы, которые уже находятся в обработке (отвечать try again later)
  - проверять кеш по интервалу и ожидать появления в нём данных от параллельного запроса

## Тестирование

При запуске ручного тестирования имитируется горизонтальное масштабирование:
  - создаётся несколько экземпляров сервиса
  - Nginx используется как балансировщик

## Environment variables

| Имя                                    | Описание                                                                                      | Значение по умолчанию                    |
| -------------------------------------- | --------------------------------------------------------------------------------------------- | ---------------------------------------- |
| LOG_LEVEL                              | Уровень логирования                                                                           | info                                     |
| CPU                                    | Количество используемых логических процессоров                                                | Максимально доступное (runtime.NumCPU()) |
| REDIS_HOST                             | Адрес Redis                                                                                   | redis:6379                               |
| REDIS_PASSWORD                         | Пароль Redis                                                                                  |                                          |
| REDIS_DATABASE                         | База данных Redis                                                                             | 0                                        |
| HTTP_CLIENT_TIMEOUT                    | Время на выполнение внешнего запроса                                                          | 3s                                       |
| HTTP_CLIENT_KEEP_ALIVE                 | Интервал времени между keep-alive                                                             | 30s                                      |
| HTTP_CLIENT_MAX_IDLE_CONNS_PER_HOST    | Максимальное количество простаивающих соединений                                              | 10000                                    |
| HTTP_CLIENT_MAX_CONNS_PER_HOST         | Максимальное количество соединений                                                            | 0 (без ограничений)                      |
| PARSER_ENDPOINT                        | Адрес для получения данных о тестируемых ресурсах                                             |                                          |
| PARSER_IN_PROGRESS_CACHE_EXPIRATION    | Время на которе блокируется получение данных о тестируемых ресурсах (для идентичных запросов) | 4s                                       |
| PARSER_CACHE_EXPIRATION                | Время кеширования данных о тестируемых ресурсах                                               | 24h                                      |
| BENCHMARK_CONCURRENCY                  | Количество параллельно тестируемых url                                                        | 5                                        |
| BENCHMARK_REQUESTS_LIMIT               | Лимит сообщений для тестируемого url                                                          | 100                                      |
| BENCHMARK_IN_PROGRESS_CACHE_EXPIRATION | Время на которе блокируется тестирование ресурса (для идентичных запросов)                    | 4s                                       |
| BENCHMARK_CACHE_EXPIRATION             | Время кеширования количества параллельных запросов                                            | 24h                                      |
| HTTP_HANDLER_TIME_TO_RESPONSE          | Время за которое сервис должен предоставить ответ                                             | 30s                                      |
| HTTP_EXTERNAL_SERVER_ADDRESS           | Адрес внешнего HTTP сервера                                                                   | :8080                                    |
| HTTP_EXTERNAL_SERVER_READ_TIMEOUT      | Время на чтение заголовков и тела входящего запроса                                           | 2s                                       |
| HTTP_EXTERNAL_SERVER_WRITE_TIMEOUT     | Время на формирование ответа и его отправку                                                   | 2s                                       |
| HTTP_EXTERNAL_SERVER_SHUTDOWN_TIMEOUT  | Время на остановку внешнего HTTP сервера                                                      | 10s                                      |
| HTTP_INTERNAL_SERVER_ADDRESS           | Адрес внутреннего HTTP сервера                                                                | :8090                                    |
| HTTP_INTERNAL_SERVER_READ_TIMEOUT      | Время на чтение заголовков и тела входящего запроса                                           | 2s                                       |
| HTTP_INTERNAL_SERVER_WRITE_TIMEOUT     | Время на формирование ответа и его отправку                                                   | 2s                                       |
| HTTP_INTERNAL_SERVER_SHUTDOWN_TIMEOUT  | Время на остановку внутреннего HTTP сервера                                                   | 10s                                      |

## Makefile

| Target     | Описание                                                           |
| -----------| ------------------------------------------------------------------ |
| lint       | Запускает статический анализ кода                                  |
| unit       | Запускает `unit`-тесты                                             |
| build      | Выполняет `lint`, `unit` и собирает `docker`-образ приложения      |
| adown      | Очищает окружение созданное для проведения приёмочных тестов       |
| acceptance | Выполняет `adown` и создаёт окружение и запускает приёмочные тесты |
| test       | Выполняет `build` и `acceptance`                                   |
| push       | Отправляет `docker`-образ приложения в хранилище                   |
| release    | Выполняет `build` и `push`                                         |
| deploy     | Инициирует выгрузку куда-либо                                      |
| down       | Очищает окружение созданное для ручного тестирования               |
| up         | Выполняет `down` и создаёт окружение для ручного тестирования      |
| redis      | Для быстрого открытия `redis-cli`                                  |

## Взаимодействие с сервисом

### Запрос

```
curl http://127.0.0.1:8080/sites?search=playstation%20купить
```

### Ответ

```
{
    "sony.ru": 123,
    "yandex.ru": 123,
    "playstation.com": 123,
    "mvideo.ru": 123,
    "e-katalog.ru": 123,
    "dns-shop.ru": 123,
    "eldorado.ru": 123,
    "avito.ru": 123,
    "m-playstation.store": 123,
    "igroray.ru": 123,
    "portagame.ru": 123,
    "sbermegamarket.ru": 123,
    "svyaznoy.ru": 123,
    "wildberries.ru": 123,
    "ozon.ru": 123,
    "citilink.ru": 123,
    "s-centreonline.ru": 123,
    "tex-soyuz.ru": 123,
    "youla.ru": 123,
    "tiu.ru": 123,
    "3dgameshop.ru": 123,
    "game77.ru": 123,
    "gamepark.ru": 123,
    "videoigr.net": 123,
    "1c-interes.ru": 123,
    "gamefanats.ru": 123,
    "televizory-moscow.ru": 123,
    "offo.ru": 123,
    "game-pristavka.ru": 123,
    "pleer.ru": 123,
    "fotosklad.ru": 123,
    "66game.ru": 123,
    "snik.co": 123,
    "yandex.ru": 123,
    "vashaigra.ru": 123,
    "game-port.online": 123,
    "onlinetrade.ru": 123,
    "icases.ru": 123,
    "regmarkets.ru": 123,
    "nextgame.net": 123,
    "savelagame.ru": 123,
    "itgame.su": 123,
    "ps-official.ru": 123,
    "xxlgame.ru": 123,
    "terra-game.ru": 123,
    "ebay.com": 123,
    "kcentr.ru": 123,
    "aliexpress.ru": 123,
    "satom.ru": 123,
    "price.ru": 123
}
```

## TODO

- Тест main.go?
- Для некоторых решений можно было бы использовать уже готовые библиотеки:
  - github.com/spf13/viper для конфигурации
  - gin, fasthttp, gorilla/mux, etc. для замены стандартного сервера
  - github.com/tsenart/vegeta для тестирования url
  - github.com/pkg/errors для ошибок
- Если адрес Redis не указан, то сервис должен работать без кеша
- Запуск сборки и тестов в CI (в Gitlab это было бы без проблем, а тут, в Github, не разбирался)
- Стабы сервисов можно было бы заменить на Nginx
